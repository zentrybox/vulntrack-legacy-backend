"""
Main Vulnerability Scanner Service
Orchestrates the vulnerability scanning pipeline:
1. Brave Search
2. Filter results with AI
3. Return clean vulnerability data
"""

import asyncio
import logging
from datetime import datetime, timezone
from typing import Any, Dict, List

from app.services.external_apis import brave_search_service, gemini_ai_service

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    def __init__(self):
        self.enabled = True
        self.rate_limit_delay = 1.0
        self.batch_size = 5

    async def scan_device(self, device: dict[str, Any]) -> Dict[str, Any]:
        """
        Scan a single device for vulnerabilities (Supabase dict)
        """
        if not self.enabled:
            return {"scan_enabled": False, "vulnerabilities": []}

        device_info = {
            "brand": device.get("brand"),
            "model": device.get("model"),
            "version": device.get("version"),
            "hostname": device.get("hostname"),
            "device_id": str(device.get("id")),
        }
        logger.info(
            f"🔎 Starting vulnerability scan for {device_info['brand']} {device_info['model']} {device_info['version']}"
        )
        logger.info(f"📋 Device Info: {device_info}")

        try:
            # Step 1: Web search for vulnerabilities
            logger.info("🌐 Calling Brave Search API...")
            search_results = await brave_search_service.search_vulnerabilities(
                brand=device_info["brand"],
                model=device_info["model"],
                version=device_info["version"],
            )

            logger.info(f"🌐 Brave Search Results: {search_results}")
            if not search_results.get("web", {}).get("results"):
                logger.info("No web search results found")
                return {
                    "device_info": device_info,
                    "scan_timestamp": datetime.now(timezone.utc).isoformat(),
                    "source": "web_search",
                    "vulnerabilities_found": False,
                    "vulnerability_count": 0,
                    "vulnerabilities": [],
                    "confidence_score": 0.8,
                    "ai_analysis_used": False,
                }

            # Step 2: Filter and analyze web results with AI
            web_results = search_results["web"]["results"]
            logger.info(f"Analyzing {len(web_results)} web search results with AI")

            ai_analysis = await gemini_ai_service.filter_vulnerability_results(
                search_results=web_results, device_info=device_info
            )

            return {
                "device_info": device_info,
                "scan_timestamp": datetime.now(timezone.utc).isoformat(),
                "source": "web_search_ai_filtered",
                "vulnerabilities_found": ai_analysis.get("vulnerability_found", False),
                "vulnerability_count": len(ai_analysis.get("vulnerabilities", [])),
                "vulnerabilities": [
                    {
                        **vuln,
                        "remediation": vuln.get("remediation", ""),
                        "details": vuln.get("details", ""),
                    }
                    for vuln in ai_analysis.get("vulnerabilities", [])
                ],
                "confidence_score": str(ai_analysis.get("confidence_score", "0.0")),
                "ai_analysis_used": True,
                "ai_summary": ai_analysis.get("summary", ""),
                "false_positives_filtered": ai_analysis.get(
                    "false_positives_filtered", 0
                ),
                "raw_search_count": len(web_results),
            }

        except Exception as e:
            logger.error(f"Error scanning device {device_info['hostname']}: {e}")
            return {
                "device_info": device_info,
                "scan_timestamp": datetime.now(timezone.utc).isoformat(),
                "error": str(e),
                "vulnerabilities_found": False,
                "vulnerability_count": 0,
                "vulnerabilities": [],
            }

    async def scan_devices_batch(
        self, devices: List[dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Scan multiple devices for vulnerabilities in batches (Supabase dicts)
        """
        if not self.enabled:
            return []

        total_devices = len(devices)
        logger.info(f"Starting batch vulnerability scan for {total_devices} devices")

        results = []
        # Process devices in batches to avoid overwhelming APIs
        for i in range(0, total_devices, self.batch_size):
            batch = devices[i : i + self.batch_size]
            batch_number = (i // self.batch_size) + 1
            logger.info(
                f"Processing batch {batch_number}/{(total_devices + self.batch_size - 1) // self.batch_size}"
            )
            batch_tasks = [self.scan_device(device) for device in batch]
            batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
            for device, result in zip(batch, batch_results):
                if isinstance(result, Exception):
                    logger.error(
                        f"Error scanning device {device.get('hostname')}: {result}"
                    )
                    result = {
                        "device_info": {
                            "hostname": device.get("hostname"),
                            "device_id": str(device.get("id")),
                        },
                        "error": str(result),
                        "vulnerabilities_found": False,
                    }
                results.append(result)
            if i + self.batch_size < total_devices:
                await asyncio.sleep(self.rate_limit_delay)
        return results


# Global vulnerability scanner instance
vulnerability_scanner = VulnerabilityScanner()
