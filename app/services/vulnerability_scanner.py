"""
Main Vulnerability Scanner Service
Orchestrates the vulnerability scanning pipeline:
1. Check local CVE database
2. If not found, use web search
3. Filter results with AI
4. Return clean vulnerability data
"""

import asyncio
import logging
from datetime import datetime
from typing import Any, Dict, List

from app.core.config import settings
from app.schemas.device import DeviceResponse
from app.services.cve_service import cve_service
from app.services.external_apis import brave_search_service, gemini_ai_service

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    def __init__(self):
        self.enabled = settings.vuln_scan_enabled
        self.rate_limit_delay = settings.vuln_scan_rate_limit_delay
        self.batch_size = settings.vuln_scan_batch_size

    async def scan_device(self, device: DeviceResponse) -> Dict[str, Any]:
        """
        Scan a single device for vulnerabilities

        Args:
            device: Device object with brand, model, version info

        Returns:
            Vulnerability scan results"""
        if not self.enabled:
            return {"scan_enabled": False, "vulnerabilities": []}

        device_info = {
            "brand": device.brand,
            "model": device.model,
            "version": device.version,
            "hostname": device.hostname,
            "device_id": str(device.id),
        }
        logger.info(
            f"🔎 Starting vulnerability scan for {device.brand} {device.model} {device.version}"
        )
        logger.info(f"📋 Device Info: {device_info}")

        try:
            # Step 1: Check local CVE database first (cost optimization)
            logger.info("📊 Step 1: Checking local CVE database...")
            cve_results = await cve_service.search_vulnerabilities_by_version(
                brand=device.brand, model=device.model, version=device.version
            )

            if cve_results:
                logger.info(f"✅ Found {len(cve_results)} CVEs in local database")
                logger.info(f"📄 CVE Results: {cve_results}")
                return {
                    "device_info": device_info,
                    "scan_timestamp": datetime.utcnow().isoformat(),
                    "source": "local_cve_database",
                    "vulnerabilities_found": True,
                    "vulnerability_count": len(cve_results),
                    "vulnerabilities": self._format_cve_results(cve_results),
                    "confidence_score": 0.9,  # High confidence for local CVE data
                    "ai_analysis_used": False,
                }

            # Step 2: If no local results, use web search + AI analysis
            logger.info(
                "📊 Step 2: No results in local CVE database, proceeding with web search"
            )

            # Web search for vulnerabilities
            logger.info("🌐 Calling Brave Search API...")
            search_results = await brave_search_service.search_vulnerabilities(
                brand=device.brand, model=device.model, version=device.version
            )

            logger.info(f"🌐 Brave Search Results: {search_results}")
            if not search_results.get("web", {}).get("results"):
                logger.info("No web search results found")
                return {
                    "device_info": device_info,
                    "scan_timestamp": datetime.utcnow().isoformat(),
                    "source": "web_search",
                    "vulnerabilities_found": False,
                    "vulnerability_count": 0,
                    "vulnerabilities": [],
                    "confidence_score": 0.8,  # High confidence in "no vulnerabilities"
                    "ai_analysis_used": False,
                }

            # Step 3: Filter and analyze web results with AI
            web_results = search_results["web"]["results"]
            logger.info(f"Analyzing {len(web_results)} web search results with AI")

            ai_analysis = await gemini_ai_service.filter_vulnerability_results(
                search_results=web_results, device_info=device_info
            )

            return {
                "device_info": device_info,
                "scan_timestamp": datetime.utcnow().isoformat(),
                "source": "web_search_ai_filtered",
                "vulnerabilities_found": ai_analysis.get("vulnerability_found", False),
                "vulnerability_count": len(ai_analysis.get("vulnerabilities", [])),
                "vulnerabilities": ai_analysis.get("vulnerabilities", []),
                "confidence_score": ai_analysis.get("confidence_score", 0.0),
                "ai_analysis_used": True,
                "ai_summary": ai_analysis.get("summary", ""),
                "false_positives_filtered": ai_analysis.get(
                    "false_positives_filtered", 0
                ),
                "raw_search_count": len(web_results),
            }

        except Exception as e:
            logger.error(f"Error scanning device {device.hostname}: {e}")
            return {
                "device_info": device_info,
                "scan_timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "vulnerabilities_found": False,
                "vulnerability_count": 0,
                "vulnerabilities": [],
            }

    async def scan_devices_batch(self, devices: List[DeviceResponse]) -> Dict[str, Any]:
        """
        Scan multiple devices for vulnerabilities in batches

        Args:
            devices: List of devices to scan

        Returns:
            Batch scan results
        """
        if not self.enabled:
            return {"scan_enabled": False, "results": []}

        total_devices = len(devices)
        logger.info(f"Starting batch vulnerability scan for {total_devices} devices")

        results = []
        vulnerable_devices = []

        # Process devices in batches to avoid overwhelming APIs
        for i in range(0, total_devices, self.batch_size):
            batch = devices[i : i + self.batch_size]
            batch_number = (i // self.batch_size) + 1

            logger.info(
                f"Processing batch {batch_number}/{(total_devices + self.batch_size - 1) // self.batch_size}"
            )

            # Scan devices in current batch
            batch_tasks = [self.scan_device(device) for device in batch]
            batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)

            for device, result in zip(batch, batch_results):
                if isinstance(result, Exception):
                    logger.error(f"Error scanning device {device.hostname}: {result}")
                    result = {
                        "device_info": {
                            "hostname": device.hostname,
                            "device_id": str(device.id),
                        },
                        "error": str(result),
                        "vulnerabilities_found": False,
                    }

                results.append(result)

                # Collect vulnerable devices
                if result.get("vulnerabilities_found", False):
                    vulnerable_devices.append(
                        {
                            "device": device,
                            "vulnerability_count": result.get("vulnerability_count", 0),
                            "confidence_score": result.get("confidence_score", 0.0),
                        }
                    )

            # Rate limiting between batches
            if i + self.batch_size < total_devices:
                await asyncio.sleep(self.rate_limit_delay)

        # Summary statistics
        total_vulnerable = len(vulnerable_devices)
        total_scanned = len([r for r in results if not r.get("error")])

        return {
            "scan_timestamp": datetime.utcnow().isoformat(),
            "total_devices_requested": total_devices,
            "total_devices_scanned": total_scanned,
            "total_vulnerable_devices": total_vulnerable,
            "vulnerability_rate": (total_vulnerable / total_scanned)
            if total_scanned > 0
            else 0,
            "vulnerable_devices": vulnerable_devices,
            "detailed_results": results,
            "scan_settings": {
                "batch_size": self.batch_size,
                "rate_limit_delay": self.rate_limit_delay,
                "enabled": self.enabled,
            },
        }

    def _format_cve_results(
        self, cve_results: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Format CVE results from local database into standardized format

        Args:
            cve_results: Raw CVE data from MongoDB

        Returns:
            Formatted vulnerability list
        """
        formatted = []

        for cve in cve_results:
            try:
                cve_data = cve.get("cve", {})
                cve_id = cve_data.get("CVE_data_meta", {}).get("ID", "Unknown")

                # Extract description
                descriptions = cve_data.get("description", {}).get(
                    "description_data", []
                )
                description = (
                    descriptions[0].get("value", "No description available")
                    if descriptions
                    else "No description available"
                )

                # Extract severity (if available)
                severity = "Unknown"
                if "impact" in cve_data:
                    severity = (
                        cve_data["impact"]
                        .get("baseMetricV3", {})
                        .get("cvssV3", {})
                        .get("baseSeverity", "Unknown")
                    )

                formatted.append(
                    {
                        "cve_id": cve_id,
                        "severity": severity,
                        "description": description[:200] + "..."
                        if len(description) > 200
                        else description,
                        "source": "local_cve_database",
                    }
                )

            except Exception as e:
                logger.warning(f"Error formatting CVE result: {e}")
                continue

        return formatted


# Global vulnerability scanner instance
vulnerability_scanner = VulnerabilityScanner()
