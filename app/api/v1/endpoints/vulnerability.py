"""
Vulnerability Scanning API Endpoints
Provides endpoints for scanning devices for vulnerabilities
"""

import uuid
from datetime import datetime
from typing import Any, Dict, List

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.schemas.device import DeviceResponse
from app.services.device_service import DeviceService
from app.services.vulnerability_scanner import vulnerability_scanner

router = APIRouter()


@router.post("/scan/device/{device_id}")
async def scan_single_device(
    device_id: uuid.UUID, db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    🔍 Scan a single device for vulnerabilities
      This endpoint will:
    1. Fetch device from database
    2. Check local CVE database first
    3. If no results, use web search + AI analysis
    4. Return vulnerability findings
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device_by_id(device_id)

        if not device:
            raise HTTPException(status_code=404, detail="Device not found")

        if not device.is_active:
            raise HTTPException(status_code=400, detail="Device is inactive")

        # Convert to Pydantic model for the scanner
        device_data = DeviceResponse.model_validate(device)

        # Perform vulnerability scan
        scan_result = await vulnerability_scanner.scan_device(device_data)

        return {
            "success": True,
            "message": "Vulnerability scan completed",
            "scan_result": scan_result,
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Scan failed: {str(e)}")


@router.post("/scan/devices/batch")
async def scan_multiple_devices(
    device_ids: List[uuid.UUID], db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    🔍 Scan multiple devices for vulnerabilities in batch

    Args:
        device_ids: List of device UUIDs to scan

    Returns:
        Batch scan results with summary statistics
    """
    try:
        if len(device_ids) > 50:  # Reasonable limit
            raise HTTPException(
                status_code=400,
                detail="Too many devices requested. Maximum 50 devices per batch.",
            )
        # Get devices from database
        device_service = DeviceService(db)
        devices = []

        for device_id in device_ids:
            device = device_service.get_device_by_id(device_id)
            if device and device.is_active:
                devices.append(DeviceResponse.model_validate(device))

        if not devices:
            raise HTTPException(status_code=404, detail="No active devices found")

        # Perform batch vulnerability scan
        scan_results = await vulnerability_scanner.scan_devices_batch(devices)

        return {
            "success": True,
            "message": f"Batch vulnerability scan completed for {len(devices)} devices",
            "scan_results": scan_results,
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Batch scan failed: {str(e)}")


@router.get("/scan/status")
async def get_scan_status() -> Dict[str, Any]:
    """
    📊 Get vulnerability scanning system status and configuration
    """
    from app.core.config import settings

    return {
        "vulnerability_scanning": {
            "enabled": settings.vuln_scan_enabled,
            "configuration": {
                "batch_size": settings.vuln_scan_batch_size,
                "timeout": settings.vuln_scan_timeout,
                "max_retries": settings.vuln_scan_max_retries,
                "rate_limit_delay": settings.vuln_scan_rate_limit_delay,
                "cache_ttl": settings.vuln_scan_cache_ttl,
            },
            "apis": {
                "gemini_model": settings.gemini_model,
                "gemini_configured": bool(settings.gemini_api_key),
                "brave_search_configured": bool(settings.brave_search_api_key),
                "mongodb_configured": bool(
                    settings.mongodb_url or settings.mongodb_host
                ),
            },
        }
    }


@router.post("/scan/device/{device_id}/quick")
async def quick_vulnerability_check(
    device_id: uuid.UUID, db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    ⚡ Quick vulnerability check using only local CVE database
      This endpoint only checks the local MongoDB CVE database (no web search/AI).
    Faster and cost-free, but may miss recent vulnerabilities not in local DB.
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device_by_id(device_id)

        if not device:
            raise HTTPException(status_code=404, detail="Device not found")

        # Quick check using only local CVE database
        from app.services.cve_service import cve_service

        cve_results = await cve_service.search_vulnerabilities_by_version(
            brand=device.brand, model=device.model, version=device.version
        )

        return {
            "success": True,
            "message": "Quick vulnerability check completed",
            "device_info": {
                "id": str(device.id),
                "hostname": device.hostname,
                "brand": device.brand,
                "model": device.model,
                "version": device.version,
            },
            "source": "local_cve_database_only",
            "vulnerabilities_found": len(cve_results) > 0,
            "vulnerability_count": len(cve_results),
            "vulnerabilities": (
                vulnerability_scanner._format_cve_results(cve_results)
                if cve_results
                else []
            ),
            "note": "This is a quick check using only local CVE database. For comprehensive scan, use /scan/device/{device_id}",
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Quick check failed: {str(e)}")


@router.post("/scan/device/{device_id}/local")
async def scan_device_local_only(
    device_id: uuid.UUID, db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    🏠 Scan device using ONLY local CVE database (MongoDB)

    This endpoint only checks the local MongoDB CVE database.
    Fastest and cost-free, but may miss recent vulnerabilities not in local DB.
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device_by_id(device_id)

        if not device:
            raise HTTPException(status_code=404, detail="Device not found")

        if not device.is_active:
            raise HTTPException(status_code=400, detail="Device is inactive")

        # Search only in local CVE database
        from app.services.cve_service import cve_service

        cve_results = await cve_service.search_vulnerabilities_by_version(
            brand=device.brand, model=device.model, version=device.version
        )

        return {
            "success": True,
            "message": "Local CVE database scan completed",
            "source": "local_cve_database_only",
            "device_info": {
                "id": str(device.id),
                "hostname": device.hostname,
                "brand": device.brand,
                "model": device.model,
                "version": device.version,
            },
            "vulnerabilities_found": len(cve_results) > 0,
            "vulnerability_count": len(cve_results),
            "vulnerabilities": (
                vulnerability_scanner._format_cve_results(cve_results)
                if cve_results
                else []
            ),
            "confidence_score": (
                0.9 if cve_results else 0.8
            ),  # High confidence for local data
            "scan_timestamp": datetime.utcnow().isoformat(),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Local scan failed: {str(e)}")


@router.post("/scan/device/{device_id}/ai")
async def scan_device_ai_only(
    device_id: uuid.UUID, db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    🤖 Scan device using ONLY Gemini AI direct knowledge

    This endpoint uses only Gemini AI's built-in knowledge to assess vulnerabilities.
    Fast and uses AI knowledge, but limited to AI's training data cutoff.
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device_by_id(device_id)

        if not device:
            raise HTTPException(status_code=404, detail="Device not found")

        if not device.is_active:
            raise HTTPException(status_code=400, detail="Device is inactive")

        # Use Gemini AI direct knowledge
        from app.services.external_apis import gemini_ai_service

        device_info = {
            "brand": device.brand,
            "model": device.model,
            "version": device.version,
        }

        # Create a direct AI knowledge prompt
        ai_prompt = f"""
You are a cybersecurity expert. Analyze this device for known vulnerabilities using your knowledge:

Device: {device.brand} {device.model} version {device.version}

Please provide known vulnerabilities for this specific device and version. Only include confirmed CVEs and security issues.

Response format (JSON only):
{{
    "vulnerability_found": true/false,
    "confidence_score": 0.0-1.0,
    "vulnerabilities": [
        {{
            "cve_id": "CVE-YYYY-XXXXX",
            "severity": "Critical/High/Medium/Low",
            "description": "Brief description",
            "cvss_score": "X.X"
        }}
    ],
    "summary": "Brief explanation of findings",
    "knowledge_cutoff_note": "Note about AI knowledge limitations"
}}
"""

        # Call Gemini AI directly
        ai_result = await gemini_ai_service.filter_vulnerability_results(
            search_results=[
                {"title": "Direct AI Knowledge Query", "description": ai_prompt}
            ],
            device_info=device_info,
        )

        return {
            "success": True,
            "message": "Gemini AI direct knowledge scan completed",
            "source": "gemini_ai_direct_knowledge",
            "device_info": {
                "id": str(device.id),
                "hostname": device.hostname,
                "brand": device.brand,
                "model": device.model,
                "version": device.version,
            },
            "vulnerabilities_found": ai_result.get("vulnerability_found", False),
            "vulnerability_count": len(ai_result.get("vulnerabilities", [])),
            "vulnerabilities": ai_result.get("vulnerabilities", []),
            "confidence_score": ai_result.get("confidence_score", 0.0),
            "ai_summary": ai_result.get("summary", ""),
            "scan_timestamp": datetime.utcnow().isoformat(),
            "note": "This scan uses only Gemini AI's built-in knowledge, limited by training data cutoff",
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"AI scan failed: {str(e)}")


@router.post("/scan/device/{device_id}/web")
async def scan_device_web_only(
    device_id: uuid.UUID, db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    🌐 Scan device using ONLY web search (Brave Search + AI filtering)

    This endpoint uses web search to find recent vulnerability information,
    then filters results with AI. Most comprehensive but slower and uses API quotas.
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device_by_id(device_id)

        if not device:
            raise HTTPException(status_code=404, detail="Device not found")

        if not device.is_active:
            raise HTTPException(status_code=400, detail="Device is inactive")

        # Use only web search + AI filtering
        from app.services.external_apis import brave_search_service, gemini_ai_service

        device_info = {
            "brand": device.brand,
            "model": device.model,
            "version": device.version,
        }

        # Web search for vulnerabilities
        search_results = await brave_search_service.search_vulnerabilities(
            brand=device.brand, model=device.model, version=device.version
        )

        if not search_results.get("web", {}).get("results"):
            return {
                "success": True,
                "message": "Web search completed - no results found",
                "source": "web_search_only",
                "device_info": {
                    "id": str(device.id),
                    "hostname": device.hostname,
                    "brand": device.brand,
                    "model": device.model,
                    "version": device.version,
                },
                "vulnerabilities_found": False,
                "vulnerability_count": 0,
                "vulnerabilities": [],
                "confidence_score": 0.8,  # High confidence in "no vulnerabilities found"
                "scan_timestamp": datetime.utcnow().isoformat(),
                "search_results_count": 0,
            }

        # Filter and analyze web results with AI
        web_results = search_results["web"]["results"]
        ai_analysis = await gemini_ai_service.filter_vulnerability_results(
            search_results=web_results, device_info=device_info
        )

        return {
            "success": True,
            "message": "Web search + AI filtering completed",
            "source": "web_search_ai_filtered",
            "device_info": {
                "id": str(device.id),
                "hostname": device.hostname,
                "brand": device.brand,
                "model": device.model,
                "version": device.version,
            },
            "vulnerabilities_found": ai_analysis.get("vulnerability_found", False),
            "vulnerability_count": len(ai_analysis.get("vulnerabilities", [])),
            "vulnerabilities": ai_analysis.get("vulnerabilities", []),
            "confidence_score": ai_analysis.get("confidence_score", 0.0),
            "ai_summary": ai_analysis.get("summary", ""),
            "false_positives_filtered": ai_analysis.get("false_positives_filtered", 0),
            "raw_search_count": len(web_results),
            "search_results_count": len(web_results),
            "scan_timestamp": datetime.utcnow().isoformat(),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Web scan failed: {str(e)}")


# ...existing code...
# ...existing code...
