"""
Vulnerability Scanning API Endpoints
Provides endpoints for scanning devices for vulnerabilities
"""
from fastapi import APIRouter, HTTPException, Depends
from typing import List, Dict, Any
import uuid
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.schemas.device import DeviceResponse
from app.services.vulnerability_scanner import vulnerability_scanner
from app.services.device_service import DeviceService

router = APIRouter()

@router.post("/scan/device/{device_id}")
async def scan_single_device(
    device_id: uuid.UUID,
    db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    ðŸ” Scan a single device for vulnerabilities
    
    This endpoint will:
    1. Fetch device from database
    2. Check local CVE database first
    3. If no results, use web search + AI analysis
    4. Return vulnerability findings
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device(device_id)
        
        if not device:
            raise HTTPException(status_code=404, detail="Device not found")
        
        if not device.is_active:
            raise HTTPException(status_code=400, detail="Device is inactive")
        
        # Convert to Pydantic model for the scanner
        device_data = DeviceResponse.model_validate(device)
        
        # Perform vulnerability scan
        scan_result = await vulnerability_scanner.scan_device(device_data)
        
        return {
            "success": True,
            "message": "Vulnerability scan completed",
            "scan_result": scan_result
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Scan failed: {str(e)}")


@router.post("/scan/devices/batch")
async def scan_multiple_devices(
    device_ids: List[uuid.UUID],
    db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    ðŸ” Scan multiple devices for vulnerabilities in batch
    
    Args:
        device_ids: List of device UUIDs to scan
        
    Returns:
        Batch scan results with summary statistics
    """
    try:
        if len(device_ids) > 50:  # Reasonable limit
            raise HTTPException(
                status_code=400, 
                detail="Too many devices requested. Maximum 50 devices per batch."
            )
        
        # Get devices from database
        device_service = DeviceService(db)
        devices = []
        
        for device_id in device_ids:
            device = device_service.get_device(device_id)
            if device and device.is_active:
                devices.append(DeviceResponse.model_validate(device))
        
        if not devices:
            raise HTTPException(status_code=404, detail="No active devices found")
        
        # Perform batch vulnerability scan
        scan_results = await vulnerability_scanner.scan_devices_batch(devices)
        
        return {
            "success": True,
            "message": f"Batch vulnerability scan completed for {len(devices)} devices",
            "scan_results": scan_results
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Batch scan failed: {str(e)}")


@router.get("/scan/status")
async def get_scan_status() -> Dict[str, Any]:
    """
    ðŸ“Š Get vulnerability scanning system status and configuration
    """
    from app.core.config import settings
    
    return {
        "vulnerability_scanning": {
            "enabled": settings.vuln_scan_enabled,
            "configuration": {
                "batch_size": settings.vuln_scan_batch_size,
                "timeout": settings.vuln_scan_timeout,
                "max_retries": settings.vuln_scan_max_retries,
                "rate_limit_delay": settings.vuln_scan_rate_limit_delay,
                "cache_ttl": settings.vuln_scan_cache_ttl
            },
            "apis": {
                "gemini_model": settings.gemini_model,
                "gemini_configured": bool(settings.gemini_api_key),
                "brave_search_configured": bool(settings.brave_search_api_key),
                "mongodb_configured": bool(settings.mongodb_url or settings.mongodb_host)
            }
        }
    }


@router.post("/scan/device/{device_id}/quick")
async def quick_vulnerability_check(
    device_id: uuid.UUID,
    db: Session = Depends(get_db)
) -> Dict[str, Any]:
    """
    âš¡ Quick vulnerability check using only local CVE database
    
    This endpoint only checks the local MongoDB CVE database (no web search/AI).
    Faster and cost-free, but may miss recent vulnerabilities not in local DB.
    """
    try:
        # Get device from database
        device_service = DeviceService(db)
        device = device_service.get_device(device_id)
        
        if not device:
            raise HTTPException(status_code=404, detail="Device not found")
        
        # Quick check using only local CVE database
        from app.services.cve_service import cve_service
        
        cve_results = await cve_service.search_vulnerabilities_by_version(
            brand=device.brand,
            model=device.model,
            version=device.version
        )
        
        return {
            "success": True,
            "message": "Quick vulnerability check completed",
            "device_info": {
                "id": str(device.id),
                "hostname": device.hostname,
                "brand": device.brand,
                "model": device.model,
                "version": device.version
            },
            "source": "local_cve_database_only",
            "vulnerabilities_found": len(cve_results) > 0,
            "vulnerability_count": len(cve_results),
            "vulnerabilities": vulnerability_scanner._format_cve_results(cve_results) if cve_results else [],
            "note": "This is a quick check using only local CVE database. For comprehensive scan, use /scan/device/{device_id}"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Quick check failed: {str(e)}")
