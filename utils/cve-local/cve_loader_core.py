#!/usr/bin/env python3
"""
CVE Loader Core Module
Handles the core functionality for loading CVE data into MongoDB
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from pymongo import MongoClient, UpdateOne
from pymongo.errors import BulkWriteError, ConnectionFailure


class CVELoader:
    """Core CVE loader class"""

    def __init__(self, mongo_uri: str = "mongodb://user:password@localhost:27017/"):
        self.mongo_uri = mongo_uri
        self.client = None
        self.db = None
        self.collection = None
        self.cve_data_dir = Path(__file__).parent / "cves"

    def connect(self) -> bool:
        """Connect to MongoDB"""
        try:
            self.client = MongoClient(self.mongo_uri, serverSelectionTimeoutMS=5000)
            self.client.admin.command("ismaster")

            self.db = self.client.cve_db
            self.collection = self.db.vulnerabilities

            # Create indexes
            self.collection.create_index("cveId", unique=True)
            self.collection.create_index("datePublished")
            self.collection.create_index("severity.baseScore")
            self.collection.create_index("affected.vendor")
            self.collection.create_index("affected.product")

            return True
        except ConnectionFailure:
            return False

    def extract_cve_data(self, cve_json: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Extract and clean CVE data from raw JSON"""
        try:
            metadata = cve_json.get("cveMetadata", {})
            cve_id = metadata.get("cveId")

            if not cve_id:
                return None

            containers = cve_json.get("containers", {})
            cna_data = containers.get("cna", {})

            # Extract affected products
            affected = cna_data.get("affected", [])
            affected_products = []

            for item in affected:
                vendor = item.get("vendor", "")
                product = item.get("product", "")
                versions = item.get("versions", [])

                for version in versions:
                    affected_products.append(
                        {
                            "vendor": vendor,
                            "product": product,
                            "version": version.get("version", ""),
                            "status": version.get("status", ""),
                        }
                    )

            # Extract CVSS severity
            metrics = cna_data.get("metrics", [])
            severity_info = {}

            for metric in metrics:
                if "cvssV3_1" in metric:
                    cvss = metric["cvssV3_1"]
                    severity_info = {
                        "baseScore": cvss.get("baseScore"),
                        "baseSeverity": cvss.get("baseSeverity"),
                        "vectorString": cvss.get("vectorString"),
                    }
                    break
                elif "cvssV3_0" in metric:
                    cvss = metric["cvssV3_0"]
                    severity_info = {
                        "baseScore": cvss.get("baseScore"),
                        "baseSeverity": cvss.get("baseSeverity"),
                        "vectorString": cvss.get("vectorString"),
                    }
                    break

            # Extract description
            descriptions = cna_data.get("descriptions", [])
            description_text = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    description_text = desc.get("value", "")
                    break

            # Extract CWE IDs
            problem_types = cna_data.get("problemTypes", [])
            cwe_ids = []

            for pt in problem_types:
                for desc in pt.get("descriptions", []):
                    if desc.get("type") == "CWE":
                        cwe_id = desc.get("cweId")
                        if cwe_id:
                            cwe_ids.append(cwe_id)

            # Extract references
            references = cna_data.get("references", [])
            ref_urls = [ref.get("url") for ref in references if ref.get("url")]

            # Build document
            return {
                "cveId": cve_id,
                "dataType": cve_json.get("dataType"),
                "dataVersion": cve_json.get("dataVersion"),
                "state": metadata.get("state"),
                "dateReserved": metadata.get("dateReserved"),
                "datePublished": metadata.get("datePublished"),
                "dateUpdated": metadata.get("dateUpdated"),
                "title": cna_data.get("title", ""),
                "description": description_text,
                "affected": affected_products,
                "severity": severity_info,
                "cweIds": cwe_ids,
                "references": ref_urls,
                "loadedAt": datetime.utcnow().isoformat(),
            }

        except Exception:
            return None

    def process_file(self, file_path: Path) -> Optional[Dict[str, Any]]:
        """Process a single CVE JSON file"""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                cve_json = json.load(f)
            return self.extract_cve_data(cve_json)
        except Exception:
            return None

    def load_batch(self, cve_documents: List[Dict[str, Any]]) -> int:
        """Load a batch of CVE documents"""
        if not cve_documents:
            return 0

        try:
            operations = []
            for doc in cve_documents:
                operations.append(
                    UpdateOne({"cveId": doc["cveId"]}, {"$set": doc}, upsert=True)
                )

            result = self.collection.bulk_write(operations, ordered=False)
            return result.upserted_count + result.modified_count

        except BulkWriteError as e:
            return len(cve_documents) - len(e.details.get("writeErrors", []))
        except Exception:
            return 0

    def get_stats(self) -> Dict[str, Any]:
        """Get database statistics"""
        try:
            stats = {
                "total_documents": self.collection.count_documents({}),
                "indexes": len(list(self.collection.list_indexes())),
            }

            try:
                coll_stats = self.db.command("collStats", "vulnerabilities")
                stats["total_size_mb"] = round(coll_stats["size"] / (1024 * 1024), 2)
            except Exception:
                stats["total_size_mb"] = 0

            # Get state distribution
            pipeline = [
                {"$group": {"_id": "$state", "count": {"$sum": 1}}},
                {"$sort": {"count": -1}},
            ]
            state_stats = list(self.collection.aggregate(pipeline))
            stats["by_state"] = state_stats

            # Get severity distribution
            pipeline = [
                {"$group": {"_id": "$severity.baseSeverity", "count": {"$sum": 1}}},
                {"$sort": {"count": -1}},
            ]
            severity_stats = list(self.collection.aggregate(pipeline))
            stats["by_severity"] = severity_stats

            return stats
        except Exception:
            return {
                "total_documents": 0,
                "total_size_mb": 0,
                "indexes": 0,
                "by_state": [],
                "by_severity": [],
            }

    def get_available_years(self) -> List[str]:
        """Get available years from dataset"""
        if not self.cve_data_dir.exists():
            return []

        years = []
        for year_dir in self.cve_data_dir.iterdir():
            if year_dir.is_dir() and year_dir.name.isdigit():
                years.append(year_dir.name)

        return sorted(years)

    def close(self):
        """Close database connection"""
        if self.client:
            self.client.close()
